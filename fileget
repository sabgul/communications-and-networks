#!/usr/bin/python3
# TODO mozno python3.8
import sys
import re
import socket
import ipaddress

def getArguments():
    if len(sys.argv) != 5:
        return False, None, None

    if not '-n' in sys.argv:
        return False
    else:
        index_n =  sys.argv.index('-n')  
        if index_n == 2 or index_n == 4:
            return False, None, None
        else:
            nameserver = sys.argv[index_n + 1]

    if not '-f' in sys.argv:
        return False, None, None
    else:
        index_f = sys.argv.index('-f')
        if index_f == 2 or index_f == 4:
            return False, None, None
        else:
            surl = sys.argv[index_f + 1]             

    return True, nameserver, surl


def processSurl(surl):
    # todo: fsp moze byt hocijako aj fSp
    if re.match(r"^(fsp|FSP)://([a-zA-Z]|[0-9]|[-_.])*/(.)*$", surl):
        temp = re.sub(r"^(fsp|FSP)://", '', surl)
        path = re.sub(r"^([a-zA-Z]|[0-9]|[-_.])*", '', temp)
        server = re.sub(r"/(.)*$", '', temp)

        return True, server, path
    else:
        return False, None, None


def processNameserver(nameserver):
    if re.match(r"^([0-9]|[.])*:([0-9])*$", nameserver):
        ip = re.sub(r":([0-9])*$",'',nameserver)
        port = re.sub(r"^([0-9]|[.])*:", '', nameserver)
        port = int(port)

        try:
            ipaddress.ip_address(ip)
            #socket.inet_aton(ip) # TODO check
        # except socket.error:
        #     print('Invalid ip') # TODO vymazat
        #     return False
        except:
            return False, None, None

        if not 0 < port <= 65535:
            return False, None, None

        return True, ip, port
    else:
        return False, None, None   

def getRequest(path_surl, filename, createFile):
    tcpRequest = "GET " + path_surl + " FSP/1.0\r\nAgent: xgulci00\r\n" + "Hostname: " + server_surl + "\r\n\r\n" 
    tcpRequest = bytes(tcpRequest, 'utf-8')

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as tcpSocket:
        tcpSocket.connect((received_ip, received_port))
        tcpSocket.sendall(tcpRequest)
        buffer = bytearray()
        while True:
            data = tcpSocket.recv(2048)
            if not data: break
            buffer.extend(data)
    
        tcpSocket.close()
    # TODO: odchytit hlavicku ci bol subor najdeny (Za FSP/1.0 je success, ak nie tak error)

    buffer = re.sub(b"^(FSP/1.0 Success\r\nLength:([ ]|[0-9]*)\r\n\r\n)", b'', buffer)

    if createFile:
        file = open(filename, "wb")
        file.write(buffer)
        file.close()
        return None
    else:
        return buffer    


if __name__ == "__main__":
    validArguments, nameserver, surl = getArguments()

    if not validArguments:
        print("error: invalid arguments", file=sys.stderr)
        sys.exit(-1)

    else:
        validSurl, server_surl, path_surl = processSurl(surl) 
        if not validSurl:
            print("error: invalid surl", file=sys.stderr)
            sys.exit(-1)

        validNameserver, ip_nameserver, port_nameserver = processNameserver(nameserver)
        if not validNameserver:
            print("error: invalid nameserver", file=sys.stderr)
            sys.exit(-1)

filename = re.sub(r"^(.)*/", '',path_surl)
if filename == '*':
    getAll = True
    getIndex = False
else:
    getAll = False
    getIndex = False

if filename == 'index':
    path_surl = 'index'
    getIndex = True

# -------------------------
# --- UDP communication
clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

udpRequest = "WHEREIS " + server_surl + "\r\n"
udpRequest = bytes(udpRequest, 'utf-8')

# try:
#     clientSocket.settimeout(5)
#     send("WHERE IS " + server_surl + "\r\n")
#     received_ip, address = clientSocket.recvfrom(1024) # buffer size is 1024bytes
# except socket.error:
#     print("error: invalid connection", file=sys.stderr)
#     sys.exit(-1)

clientSocket.sendto(udpRequest, (ip_nameserver, port_nameserver))
clientSocket.settimeout(5) #TODO exeption na timeout
received_data, address = clientSocket.recvfrom(2048) # buffer size is 1024bytes
clientSocket.close()

received_data = received_data.decode("utf-8") 
received_msg = re.sub(r"([0-9]|[.:])*", '', received_data)
# TODO process reived msg, if not OK, raise error
temp = re.sub(r"^([a-zA-Z]|[ ])*",'', received_data)
received_ip = re.sub(r":([0-9])*$",'', temp)
received_port = re.sub(r"^([0-9]|[.])*:",'', temp)
received_port = int(received_port)

# -------------------------
# --- TCP communication

if getAll:
    buff = getRequest('index', None, False)
    buff = buff.decode("utf-8")
    files = buff.split('\r\n')

    for file in files:
        if not '.DS_Store' in file:
            if file:
                subFilename = re.sub(r"^(.)*/", '', file)
                buff = getRequest(file, subFilename, True)
    # surl = ten prvok listu
    # filename = musim vyparsovat nove
    # create file = true

else:
    buff = getRequest(path_surl, filename, True)    

#vyparsujem si z path meno suboru, a taky isty vytvorim

    # ak to nie je DS_store, zavolam get na dany file




# ak je tam hviezdicka, musim stiahnut vsetky subory


# ./fileget -n 147.229.8.12:3333 -f fsp://foo.bar/file.txt

# zapnutie serveru:
# hodim sa do os-x zlozky v ipk- servers a spustim:
# ./fsptest -p 127.0.0.1:3333 -r ../nameserver

# ---- INFO:
# WHEREIS server.one
# OK 127.0.0.1:58388

# WHEREIS server.two
# OK 127.0.0.1:58389

# symbolicke mena sa prekladaju na IP adresy pomocou protokolu NSP
# SURL: PROTOCOL://SERVER_NAME/PATH 
#       protocol - only TCP
#       server_name - moze byt tvorene len alfanumerickymi znakmi, -, _, a .

# ak subor najdem, ulozim ho do cwd
# ak nastane chyba, vhodnym sposobom ju vypiseme a ziadny subor nebude vytvoreny

# spustenie: fileget -n NAMESERVER -f SURL
# -n a -f mozu byt v hocakom poradi
    
# osetrit? ze * nemoze byt v podzlozke
# ci nameserver existuje poslem dotaz a dam timeout na odpoved
# .settimeout a exception na socket.timeout (5 sekund a niekto opakuje kazdy poziadavok 5x keby to bol docasny problem)
# port mozem otestovat aj tak ze dam try except pri connect
# index neukladat

# po kazdom get musim odpojit socket, connect a close dat do loopu kde volam get